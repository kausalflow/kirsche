{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation for Kirsche","text":"<p>Kirsche, connecting the papers.</p> <p>Kirsche is cherry in German.</p> <p>Kirsche looks into the citations of the list of paper provided and establishes connections between each other. Kirsche can be used as a command line tool or in your python script.</p>"},{"location":"#demo","title":"Demo","text":"<p>Lu H, Shaner S, Otte E, Asplund M, Vlachos A. A microfluidic perspective on conventional in vitro transcranial direct current stimulation methods. J Neurosci Methods. 2022; 109761. doi:10.1016/j.jneumeth.2022.109761</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install kirsche\n</code></pre> <p>This will leave out many dependencies. To install kirsche together with all the requirements,</p> <pre><code>pip install \"kirsche[all]\"\n</code></pre> <p>The extras options:</p> <ul> <li><code>all</code>: everything</li> <li><code>docs</code>: required to build the docs</li> </ul>"},{"location":"#the-idea","title":"The Idea","text":"<p>The Kirsche command line tool provides a few functionalities:</p> <ol> <li>Download the metadata of the given papers. Papers can be given as a list of doi or a bib file.</li> <li>Calculate connections between the given papers.</li> <li>Visualize the connections between the given papers.</li> </ol>"},{"location":"changelog/","title":"Kirsche Changelog","text":""},{"location":"changelog/#2021-09-23-021-026","title":"2021-09-23, 0.2.1 - 0.2.6","text":"<p>Added: - Multiple files as database instead of single file - Visualization html page title is set</p>"},{"location":"changelog/#2021-09-21","title":"2021-09-21","text":"<p>Added:</p> <ul> <li>Visualizations!</li> </ul>"},{"location":"changelog/#2021-09-16-010","title":"2021-09-16, 0.1.0","text":"<p>First version!</p>"},{"location":"references/","title":"Introduction","text":""},{"location":"references/#references","title":"References","text":"<p>In this section, we provide the references for the <code>kirsche</code> codebase. For more details of how to use the package, please refer to tutorials.</p>"},{"location":"references/command/","title":"Commandline Tool","text":""},{"location":"references/command/#command-line-tool","title":"Command Line Tool","text":""},{"location":"references/command/#kirsche","title":"kirsche","text":"<p>Usage:</p> <pre><code>kirsche [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"references/command/#connections","title":"connections","text":"<p>Establish connections between the list of papers, either from a list of DOIs, bib file, or from download metadata file.</p> <pre><code>If no `metadata_file` provided, the metadata will be downloaded using parameters specified in `paper_id` or `bib_file`.\nIf `metadata_file` is provided, the connections will be established using the metadata file.\n\n## About Metadata Sources\n\nDownload paper data from service provides (e.g., SemanticScholar).\n\nThere are two ways to provide a list of DOIs to be retrieved, provide paper DOIs directly using `--paper_id` or `-p`, or loading a bib file using `--source_bib_file` or `-sb`.\n\nTo save the downloaded data, provide a path to a file using `--target` or `-t`.\n\n\n:param paper_id: Paper DOI, optional, can be multiple\n:param source_bib_file: Bib file path, optional\n:param source_metadata_path: Target data file path, optional\n:param connected_papers_path: path to save enhanced data file with connections calcualted\n:param sleep_time: Sleep time between requests, defaults to 1sec.\n</code></pre> <p>Usage:</p> <pre><code>kirsche connections [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -p, --paper_id TEXT             Paper ID\n  -bib, --source_bib_file PATH    Bib file path\n  -meta, --source_metadata_path PATH\n                                  path to data file/folder with paper metadata\n  -t, --connected_papers_path PATH\n                                  path to save enhanced data file\n  -st, --sleep_time INTEGER       Sleep time between requests\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"references/command/#connections-from-metadata","title":"connections-from-metadata","text":"<p>Establish connections between the list of papers</p> <pre><code>:param source_metadata_path: path to data file with paper metadata\n:param connected_papers_path: path to save enhanced data file\n</code></pre> <p>Usage:</p> <pre><code>kirsche connections-from-metadata [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -s, --source_metadata_path PATH\n                                  path to data file/folder with paper metadata\n  -t, --connected_papers_path PATH\n                                  path to save enhanced data file(s)\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"references/command/#metadata","title":"metadata","text":"<p>Download paper data from service provides (e.g., SemanticScholar).</p> <pre><code>There are two ways to provide a list of DOIs to be retrieved, provide paper DOIs directly using `--paper_id` or `-p`, or loading a bib file using `--source_bib_file` or `-bib`.\n\nTo save the downloaded data, provide a path to a file using `--target_metadata_path` or `-t`.\n\n:param paper_id: Paper DOI, optional, can be multiple\n:param source_bib_file: Bib file path, optional\n:param target_metadata_path: Target data file path, optional\n:param sleep_time: Sleep time between requests, defaults to 1sec.\n</code></pre> <p>Usage:</p> <pre><code>kirsche metadata [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -p, --paper_id TEXT             Paper ID\n  -bib, --source_bib_file PATH    Bib file path\n  -t, --target_metadata_path PATH\n                                  Target data file path\n  -sleep, --sleep_time INTEGER    Sleep time between requests\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"references/command/#visualization","title":"visualization","text":"<p>Visualize the connections between the papers.</p> <p>Usage:</p> <pre><code>kirsche visualization [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -p, --source_paper_id TEXT      Source: Paper ID\n  -bib, --source_bib_file PATH    Source: Bib file path\n  -meta, --source_metadata_path PATH\n                                  Source: path to data file/folder with paper\n                                  metadata\n  -conn, --source_connected_papers_path PATH\n                                  Source: path to save enhanced data\n                                  file/folder\n  --title TEXT                    title of the chart\n  -t, --target_html_path PATH     Target: path to html file  [required]\n  -sleep, --sleep_time INTEGER    Sleep time between requests\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"references/command/#helpers","title":"Helpers","text":""},{"location":"references/command/#kirsche.command.connections","title":"<code>connections(paper_id, source_bib_file, source_metadata_path, connected_papers_path, sleep_time)</code>","text":"<p>Establish connections between the list of papers, either from a list of DOIs, bib file, or from download metadata file.</p> <p>If no <code>metadata_file</code> provided, the metadata will be downloaded using parameters specified in <code>paper_id</code> or <code>bib_file</code>. If <code>metadata_file</code> is provided, the connections will be established using the metadata file.</p>"},{"location":"references/command/#kirsche.command.connections--about-metadata-sources","title":"About Metadata Sources","text":"<p>Download paper data from service provides (e.g., SemanticScholar).</p> <p>There are two ways to provide a list of DOIs to be retrieved, provide paper DOIs directly using <code>--paper_id</code> or <code>-p</code>, or loading a bib file using <code>--source_bib_file</code> or <code>-sb</code>.</p> <p>To save the downloaded data, provide a path to a file using <code>--target</code> or <code>-t</code>.</p> <p>Parameters:</p> Name Type Description Default <code>paper_id</code> <code>Union[str, Iterable]</code> <p>Paper DOI, optional, can be multiple</p> required <code>source_bib_file</code> <code>Path</code> <p>Bib file path, optional</p> required <code>source_metadata_path</code> <code>Path</code> <p>Target data file path, optional</p> required <code>connected_papers_path</code> <code>Union[str, Path]</code> <p>path to save enhanced data file with connections calcualted</p> required <code>sleep_time</code> <code>int</code> <p>Sleep time between requests, defaults to 1sec.</p> required Source code in <code>kirsche/command.py</code> <pre><code>@kirsche.command()\n@click.option(\"--paper_id\", \"-p\", help=\"Paper ID\", multiple=True)\n@click.option(\"--source_bib_file\", \"-bib\", type=click.Path(exists=True), help=\"Bib file path\")\n@click.option(\n    \"--source_metadata_path\",\n    \"-meta\",\n    type=click.Path(exists=True),\n    help=\"path to data file/folder with paper metadata\",\n)\n@click.option(\n    \"--connected_papers_path\",\n    \"-t\",\n    type=click.Path(exists=False),\n    help=\"path to save enhanced data file\",\n)\n@click.option(\"--sleep_time\", \"-st\", default=1, help=\"Sleep time between requests\")\ndef connections(\n    paper_id: Union[str, Iterable],\n    source_bib_file: Path,\n    source_metadata_path: Path,\n    connected_papers_path: Union[str, Path],\n    sleep_time: int,\n):\n    \"\"\"Establish connections between the list of papers, either from a list of DOIs, bib file, or from download metadata file.\n\n    If no `metadata_file` provided, the metadata will be downloaded using parameters specified in `paper_id` or `bib_file`.\n    If `metadata_file` is provided, the connections will be established using the metadata file.\n\n    ## About Metadata Sources\n\n    Download paper data from service provides (e.g., SemanticScholar).\n\n    There are two ways to provide a list of DOIs to be retrieved, provide paper DOIs directly using `--paper_id` or `-p`, or loading a bib file using `--source_bib_file` or `-sb`.\n\n    To save the downloaded data, provide a path to a file using `--target` or `-t`.\n\n\n    :param paper_id: Paper DOI, optional, can be multiple\n    :param source_bib_file: Bib file path, optional\n    :param source_metadata_path: Target data file path, optional\n    :param connected_papers_path: path to save enhanced data file with connections calcualted\n    :param sleep_time: Sleep time between requests, defaults to 1sec.\n    \"\"\"\n    if isinstance(connected_papers_path, str):\n        connected_papers_path = Path(connected_papers_path)\n\n    click.secho(f\"Retrieving paper metadata...\")\n    if not source_metadata_path:\n        if source_bib_file:\n            logger.debug(f\"Using bib file: {source_bib_file}\")\n\n        if connected_papers_path.exists():\n            existing_connected_papers = load_batch_json(connected_papers_path)\n        else:\n            existing_connected_papers = []\n\n        records = _metadata(\n            paper_id,\n            source_bib_file,\n            None,\n            sleep_time,\n            existing_records=existing_connected_papers,\n        )\n    else:\n        records = load_batch_json(source_metadata_path)\n    click.secho(f\"  Retrieved {len(records)} records.\")\n\n    click.secho(f\"Connecting papers...\")\n    connected_papers = append_connections(records)\n    click.secho(f\"  Connected papers...\")\n\n    # Filter out unnecessary keys in the dictionary\n    click.secho(f\"Filtering and saving data...\")\n    connected_papers = save_connected_papers(connected_papers, target=connected_papers_path)\n    click.secho(f\"  Done...\")\n\n    if not connected_papers_path:\n        click.secho(f\"No saving path specified, printing simplified data view...\")\n        dv = DataViews(connected_papers)\n        click.echo(dv.json_simple)\n</code></pre>"},{"location":"references/command/#kirsche.command.connections_from_metadata","title":"<code>connections_from_metadata(source_metadata_path, connected_papers_path)</code>","text":"<p>Establish connections between the list of papers</p> <p>Parameters:</p> Name Type Description Default <code>source_metadata_path</code> <code>Path</code> <p>path to data file with paper metadata</p> required <code>connected_papers_path</code> <code>Path</code> <p>path to save enhanced data file</p> required Source code in <code>kirsche/command.py</code> <pre><code>@kirsche.command()\n@click.option(\n    \"--source_metadata_path\",\n    \"-s\",\n    type=click.Path(exists=True),\n    help=\"path to data file/folder with paper metadata\",\n)\n@click.option(\n    \"--connected_papers_path\",\n    \"-t\",\n    type=click.Path(exists=False),\n    help=\"path to save enhanced data file(s)\",\n)\ndef connections_from_metadata(source_metadata_path: Path, connected_papers_path: Path):\n    \"\"\"Establish connections between the list of papers\n\n    :param source_metadata_path: path to data file with paper metadata\n    :param connected_papers_path: path to save enhanced data file\n    \"\"\"\n\n    connected_papers = append_connections_for_file(source_metadata_path, connected_papers_path)\n\n    return connected_papers\n</code></pre>"},{"location":"references/command/#kirsche.command.metadata","title":"<code>metadata(paper_id, source_bib_file, target_metadata_path, sleep_time)</code>","text":"<p>Download paper data from service provides (e.g., SemanticScholar).</p> <p>There are two ways to provide a list of DOIs to be retrieved, provide paper DOIs directly using <code>--paper_id</code> or <code>-p</code>, or loading a bib file using <code>--source_bib_file</code> or <code>-bib</code>.</p> <p>To save the downloaded data, provide a path to a file using <code>--target_metadata_path</code> or <code>-t</code>.</p> <p>Parameters:</p> Name Type Description Default <code>paper_id</code> <code>Union[str, Iterable]</code> <p>Paper DOI, optional, can be multiple</p> required <code>source_bib_file</code> <code>Path</code> <p>Bib file path, optional</p> required <code>target_metadata_path</code> <code>Path</code> <p>Target data file path, optional</p> required <code>sleep_time</code> <code>Optional[int]</code> <p>Sleep time between requests, defaults to 1sec.</p> required Source code in <code>kirsche/command.py</code> <pre><code>@kirsche.command()\n@click.option(\"--paper_id\", \"-p\", help=\"Paper ID\", multiple=True)\n@click.option(\"--source_bib_file\", \"-bib\", type=click.Path(exists=True), help=\"Bib file path\")\n@click.option(\n    \"--target_metadata_path\",\n    \"-t\",\n    type=click.Path(exists=False),\n    help=\"Target data file path\",\n)\n@click.option(\"--sleep_time\", \"-sleep\", default=1, help=\"Sleep time between requests\")\ndef metadata(\n    paper_id: Union[str, Iterable],\n    source_bib_file: Path,\n    target_metadata_path: Path,\n    sleep_time: Optional[int],\n):\n    \"\"\"Download paper data from service provides (e.g., SemanticScholar).\n\n    There are two ways to provide a list of DOIs to be retrieved, provide paper DOIs directly using `--paper_id` or `-p`, or loading a bib file using `--source_bib_file` or `-bib`.\n\n    To save the downloaded data, provide a path to a file using `--target_metadata_path` or `-t`.\n\n    :param paper_id: Paper DOI, optional, can be multiple\n    :param source_bib_file: Bib file path, optional\n    :param target_metadata_path: Target data file path, optional\n    :param sleep_time: Sleep time between requests, defaults to 1sec.\n    \"\"\"\n    records = _metadata(paper_id, source_bib_file, target_metadata_path, sleep_time)\n\n    return records\n</code></pre>"},{"location":"references/command/#kirsche.command.visualization","title":"<code>visualization(source_paper_id, source_bib_file, source_metadata_path, source_connected_papers_path, title, target_html_path, sleep_time)</code>","text":"<p>Visualize the connections between the papers.</p> Source code in <code>kirsche/command.py</code> <pre><code>@kirsche.command()\n@click.option(\"--source_paper_id\", \"-p\", required=False, help=\"Source: Paper ID\", multiple=True)\n@click.option(\n    \"--source_bib_file\",\n    \"-bib\",\n    required=False,\n    type=click.Path(exists=True),\n    help=\"Source: Bib file path\",\n)\n@click.option(\n    \"--source_metadata_path\",\n    \"-meta\",\n    required=False,\n    type=click.Path(exists=True),\n    help=\"Source: path to data file/folder with paper metadata\",\n)\n@click.option(\n    \"--source_connected_papers_path\",\n    \"-conn\",\n    required=False,\n    type=click.Path(exists=True),\n    help=\"Source: path to save enhanced data file/folder\",\n)\n@click.option(\"--title\", default=\"Kirsche: Paper Graph\", help=\"title of the chart\")\n@click.option(\n    \"--target_html_path\",\n    \"-t\",\n    required=True,\n    type=click.Path(exists=False),\n    help=\"Target: path to html file\",\n)\n@click.option(\"--sleep_time\", \"-sleep\", default=1, help=\"Sleep time between requests\")\ndef visualization(\n    source_paper_id,\n    source_bib_file,\n    source_metadata_path,\n    source_connected_papers_path,\n    title,\n    target_html_path,\n    sleep_time,\n):\n    \"\"\"Visualize the connections between the papers.\"\"\"\n    if source_connected_papers_path:\n        connected_papers = load_batch_json(source_connected_papers_path)\n    else:\n        click.secho(f\"Retrieving paper metadata...\")\n        if not source_metadata_path:\n            if source_bib_file:\n                logger.debug(f\"Using bib file: {source_bib_file}\")\n            records = _metadata(source_paper_id, source_bib_file, None, sleep_time)\n        else:\n            records = load_batch_json(source_metadata_path)\n        click.secho(f\"  Retrieved {len(records)} records.\")\n\n        click.secho(f\"Connecting papers...\")\n        connected_papers = append_connections(records)\n        click.secho(f\"  Connected papers...\")\n\n        # Filter out unnecessary keys in the dictionary\n        click.secho(f\"Filtering and saving data...\")\n        connected_papers = save_connected_papers(connected_papers)\n        click.secho(f\"  Done...\")\n\n    g = PaperGraph(connected_papers, title=title)\n    nodes = g.nodes\n    edges = g.edges\n\n    click.secho(f\"Saving html file...\")\n    visualize(nodes, edges, g.title, target_html_path)\n</code></pre>"},{"location":"references/connect/","title":"Connect","text":""},{"location":"references/connect/#download","title":"download","text":""},{"location":"references/connect/#kirsche.connect.append_connections","title":"<code>append_connections(papers, connection_field_name='local__referenced_to')</code>","text":"<p>find connections between papers based on citation doi</p> <p>Parameters:</p> Name Type Description Default <code>papers</code> <code>list</code> <p>list of paper metadata</p> required <code>connection_field_name</code> <code>Optional[str]</code> <p>name of the field to save the connection info</p> <code>'local__referenced_to'</code> <p>Returns:</p> Type Description <code>list</code> <p>list of paper metadata with connection info</p> Source code in <code>kirsche/connect.py</code> <pre><code>def append_connections(\n    papers: list, connection_field_name: Optional[str] = \"local__referenced_to\"\n) -&gt; list:\n    \"\"\"find connections between papers based on citation doi\n\n    :param papers: list of paper metadata\n    :param connection_field_name: name of the field to save the connection info\n    :return: list of paper metadata with connection info\n    \"\"\"\n\n    if connection_field_name is None:\n        connection_field_name = \"local__referenced_to\"\n\n    logger.debug(f\"Appending connections to {len(papers)} papers...\")\n\n    enhanced_papers = []\n\n    for ps in papers:\n        # Convert doi to lower case\n        ps_doi = ps.get(\"doi\", \"\")\n        if not ps_doi:\n            ps_doi = \"\"\n        ps_doi = ps_doi.lower()\n        ps[\"doi\"] = ps_doi\n\n        # find references that are in the current papers list\n        ps_references = ps[\"references\"]\n        ps_reference_dois = [\n            psr.get(\"doi\", \"\").lower() for psr in ps_references if psr.get(\"doi\")\n        ]\n        ps_referenced_to = []\n        for pt in papers:\n            pt_doi = pt.get(\"doi\", \"\")\n            if not pt_doi:\n                pt_doi = \"\"\n            else:\n                pt_doi = pt_doi.lower()\n            if pt_doi in ps_reference_dois:\n                ps_referenced_to.append(pt_doi)\n\n        ps[connection_field_name] = ps_referenced_to\n        enhanced_papers.append(ps)\n\n    logger.debug(\n        f\"enhanced {len([p for p in enhanced_papers if p.get(connection_field_name)])}\"\n    )\n\n    return enhanced_papers\n</code></pre>"},{"location":"references/connect/#kirsche.connect.append_connections_for_file","title":"<code>append_connections_for_file(data_file, target=None, save_keys=None, connection_field_name='local__referenced_to')</code>","text":"<p>connect papers based on citation doi</p> <p>Parameters:</p> Name Type Description Default <code>data_file</code> <code>Union[str, Path]</code> <p>path to json file that contains the downloaded paper metadata</p> required <code>target</code> <code>Optional[Union[str, Path]]</code> <p>path to json file to save the enhanced paper metadata</p> <code>None</code> <code>save_keys</code> <code>Optional[list]</code> <p>list of keys to save from the original paper metadata</p> <code>None</code> <code>connection_field_name</code> <code>Optional[str]</code> <p>name of the field to save the connection info</p> <code>'local__referenced_to'</code> <p>Returns:</p> Type Description <p>list of paper metadata with connection info</p> Source code in <code>kirsche/connect.py</code> <pre><code>def append_connections_for_file(\n    data_file: Union[str, Path],\n    target: Optional[Union[str, Path]] = None,\n    save_keys: Optional[list] = None,\n    connection_field_name: Optional[str] = \"local__referenced_to\",\n):\n    \"\"\"connect papers based on citation doi\n\n    :param data_file: path to json file that contains the downloaded paper metadata\n    :param target: path to json file to save the enhanced paper metadata\n    :param save_keys: list of keys to save from the original paper metadata\n    :param connection_field_name: name of the field to save the connection info\n    :return: list of paper metadata with connection info\n    \"\"\"\n\n    if connection_field_name is None:\n        connection_field_name = \"local__referenced_to\"\n\n    papers = load_json(data_file)\n\n    c_p = append_connections(papers, connection_field_name=connection_field_name)\n\n    # Filter out unnecessary keys in the dictionary\n    c_p = save_connected_papers(\n        c_p,\n        target=target,\n        save_keys=save_keys,\n        connection_field_name=connection_field_name,\n    )\n\n    return c_p\n</code></pre>"},{"location":"references/dataset/","title":"Dataset","text":""},{"location":"references/dataset/#download","title":"download","text":""},{"location":"references/dataset/#kirsche.dataset.DataViews","title":"<code>DataViews</code>","text":"Source code in <code>kirsche/dataset.py</code> <pre><code>class DataViews:\n    def __init__(self, data) -&gt; None:\n        if not data:\n            logger.warning(\"No data provided!\")\n            self.data = []\n        else:\n            self.data = data\n\n    @property\n    def json_full(self):\n        \"\"\"JSON representation of the full data\"\"\"\n        return json.dumps(self.data, indent=4)\n\n    @property\n    def json_simple(self):\n        \"\"\"JSON representation of a few selected keys of the data\"\"\"\n\n        records = []\n        for record in self.data:\n            records.append(self._json__simple(record))\n\n        return json.dumps(records, indent=4)\n\n    @staticmethod\n    def _json__simple(record, show_keys=None, connection_field_name=None) -&gt; str:\n        \"\"\"Show only some keys of a record\"\"\"\n\n        if connection_field_name is None:\n            connection_field_name = \"local__referenced_to\"\n\n        if show_keys is None:\n            show_keys = [\n                \"doi\",\n                \"authors\",\n                \"title\",\n                \"venue\",\n                \"year\",\n                \"numCitedBy\",\n                \"numCiting\",\n                f\"{connection_field_name}_count\",\n            ]\n\n        if f\"{connection_field_name}_count\" not in record:\n            record[f\"{connection_field_name}_count\"] = len(\n                record.get(connection_field_name, [])\n            )\n\n        record = {k: v for k, v in record.items() if k in show_keys}\n\n        return record\n</code></pre>"},{"location":"references/dataset/#kirsche.dataset.DataViews.json_full","title":"<code>json_full</code>  <code>property</code>","text":"<p>JSON representation of the full data</p>"},{"location":"references/dataset/#kirsche.dataset.DataViews.json_simple","title":"<code>json_simple</code>  <code>property</code>","text":"<p>JSON representation of a few selected keys of the data</p>"},{"location":"references/dataset/#kirsche.dataset.Dataset","title":"<code>Dataset</code>","text":"<p>Dataset to prepare data about papers.</p> <p>There are two groups of keys and transformations: - <code>builtin_keys</code>, and - <code>additional_keys</code>.</p> <p><code>builtin_keys</code> are keys that are always present in the dataset. <code>additional_keys</code> are the keys that may appear in the additional data in <code>labels</code>.</p> <p><code>builtin_keys</code> param is default to</p> <pre><code>builtin_keys = [\n    {\"key\": \"authors\", \"transform\": format_authors},\n    {\"key\": \"year\"},\n    {\"key\": \"numCitedBy\"},\n    {\"key\": \"numCiting\"},\n]\n</code></pre> <p><code>format_authors</code> is a built-in function to format authors.</p> <p><code>extra_data</code> should be a dictionary that use the DOI as keys and list of</p> <p>Parameters:</p> Name Type Description Default <code>papers</code> <code>list</code> <p>list of paper metadata with the connections between each other</p> required <code>extra_data</code> <code>dict</code> <p>additional data about the papers</p> <code>None</code> <code>extra_data_use_keys</code> <code>list</code> <p>use only these keys from the labels provided, defaults to all keys in the provided extra_data</p> <code>None</code> <code>additional_keys</code> <code>list</code> <p>list of additional keys to use for the data</p> <code>None</code> <code>builtin_keys</code> <code>list</code> <p>list of keys and corresponding transformation to use for the data, defaults to [{\"key\": \"authors\", \"transform\": format_authors}, {\"key\": \"year\"}, {\"key\": \"numCitedBy\"}, {\"key\": \"numCiting\"}]</p> <code>None</code> <code>connection_field_name</code> <code>str</code> <p>name of the field to use for the connections between papers</p> <code>None</code> Source code in <code>kirsche/dataset.py</code> <pre><code>class Dataset:\n    \"\"\"\n    Dataset to prepare data about papers.\n\n    There are two groups of keys and transformations:\n    - `builtin_keys`, and\n    - `additional_keys`.\n\n    `builtin_keys` are keys that are always present in the dataset. `additional_keys` are the keys that may appear in the additional data in `labels`.\n\n    `builtin_keys` param is default to\n\n    ```\n    builtin_keys = [\n        {\"key\": \"authors\", \"transform\": format_authors},\n        {\"key\": \"year\"},\n        {\"key\": \"numCitedBy\"},\n        {\"key\": \"numCiting\"},\n    ]\n    ```\n\n    `format_authors` is a built-in function to format authors.\n\n    `extra_data` should be a dictionary that use the DOI as keys and list of\n\n    :param papers: list of paper metadata with the connections between each other\n    :type papers: list\n    :param extra_data: additional data about the papers\n    :type extra_data: dict\n    :param extra_data_use_keys: use only these keys from the labels provided, defaults to all keys in the provided extra_data\n    :type extra_data_use_keys: list\n    :param additional_keys: list of additional keys to use for the data\n    :type additional_keys: list\n    :param builtin_keys: list of keys and corresponding transformation to use for the data, defaults to [{\"key\": \"authors\", \"transform\": format_authors}, {\"key\": \"year\"}, {\"key\": \"numCitedBy\"}, {\"key\": \"numCiting\"}]\n    :type builtin_keys: list\n    :param connection_field_name: name of the field to use for the connections between papers\n    :type connection_field_name: str\n    \"\"\"\n\n    def __init__(\n        self,\n        papers,\n        extra_data=None,\n        extra_data_use_keys=None,\n        additional_keys=None,\n        builtin_keys=None,\n        connection_field_name=None,\n    ):\n\n        if connection_field_name is None:\n            connection_field_name = \"local__referenced_to\"\n        self.connection_field_name = connection_field_name\n\n        if builtin_keys is None:\n            builtin_keys = [\n                {\"key\": \"authors\", \"transform\": format_authors},\n                {\"key\": \"year\"},\n                {\"key\": \"numCitedBy\"},\n                {\"key\": \"numCiting\"},\n            ]\n\n        self.builtin_keys = builtin_keys\n\n        if additional_keys is None:\n            if not extra_data:\n                additional_keys = []\n            else:\n                for doi in extra_data:\n                    additional_keys = [{\"key\": k} for k in extra_data[doi].keys()]\n                    break\n\n        self.additional_keys = additional_keys\n\n        self.keys = builtin_keys + additional_keys\n\n        self._papers = papers\n        self.extra_data = extra_data\n        self.extra_data_use_keys = extra_data_use_keys\n\n    @property\n    def papers(self):\n        \"\"\"Calculate papers property\"\"\"\n\n        if self.extra_data:\n            papers = add_additional_data_to_papers(\n                self._papers, self.extra_data, self.extra_data_use_keys\n            )\n        else:\n            papers = self._papers\n\n        # Add connections\n        papers = append_connections(\n            papers, connection_field_name=self.connection_field_name\n        )\n\n        return papers\n\n    @property\n    def lut(self):\n        \"\"\"Transform the paper records into key value dictionary with the key being DOI.\"\"\"\n        return {p[\"doi\"].lower(): p for p in self.papers}\n\n    @property\n    def data(self):\n        scatter_data = {}\n        for key in self.keys:\n            scatter_data[key[\"key\"]] = self._transform_records(\n                key[\"key\"],\n                self.papers,\n                default_value=key.get(\"default_value\", None),\n                transform=key.get(\"transform\", None),\n            )\n\n        return scatter_data\n\n    def connections(\n        self, col_x_axis, col_y_axis, col_x_default=None, col_y_default=None\n    ):\n        \"\"\"Calculate connections (node to node)\n\n        As this is already calculating the coordinates, we have to specify the columns that are used for the x and y axis. These coordinates should be numerical.\n\n        :param col_x_axis: name of the column to use for the x axis\n        :type col_x_axis: str\n        :param col_y_axis: name of the column to use for the y axis\n        :type col_y_axis: str\n        :param col_x_default: default value to use for the x axis, defaults to None\n        :type col_x_default: str, optional\n        :param col_y_default: default value to use for the y axis, defaults to None\n        :type col_y_default: str, optional\n        :return: list of connections\n        :rtype: list\n        \"\"\"\n\n        lut = self.lut\n        papers = self.papers\n\n        connection_data = [\n            [\n                (\n                    lut[p[\"doi\"]].get(col_x_axis, col_x_default),\n                    lut[p[\"doi\"]].get(col_y_axis, col_y_default),\n                ),\n                (\n                    lut[pt_doi].get(col_x_axis, col_x_default),\n                    lut[pt_doi].get(col_y_axis, col_y_default),\n                ),\n            ]\n            for p in papers\n            for pt_doi in p[self.connection_field_name]\n        ]\n        return connection_data\n\n    @staticmethod\n    def _transform_records(key, papers, default_value=None, transform=None):\n        \"\"\"A generic parser to get and transform values from the paper records\"\"\"\n\n        if transform is None:\n            transform = lambda x: x.get(key, default_value)\n\n        data = [transform(p) for p in papers]\n\n        return data\n</code></pre>"},{"location":"references/dataset/#kirsche.dataset.Dataset.lut","title":"<code>lut</code>  <code>property</code>","text":"<p>Transform the paper records into key value dictionary with the key being DOI.</p>"},{"location":"references/dataset/#kirsche.dataset.Dataset.papers","title":"<code>papers</code>  <code>property</code>","text":"<p>Calculate papers property</p>"},{"location":"references/dataset/#kirsche.dataset.Dataset.connections","title":"<code>connections(col_x_axis, col_y_axis, col_x_default=None, col_y_default=None)</code>","text":"<p>Calculate connections (node to node)</p> <p>As this is already calculating the coordinates, we have to specify the columns that are used for the x and y axis. These coordinates should be numerical.</p> <p>Parameters:</p> Name Type Description Default <code>col_x_axis</code> <code>str</code> <p>name of the column to use for the x axis</p> required <code>col_y_axis</code> <code>str</code> <p>name of the column to use for the y axis</p> required <code>col_x_default</code> <code>str, optional</code> <p>default value to use for the x axis, defaults to None</p> <code>None</code> <code>col_y_default</code> <code>str, optional</code> <p>default value to use for the y axis, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>list of connections</p> Source code in <code>kirsche/dataset.py</code> <pre><code>def connections(\n    self, col_x_axis, col_y_axis, col_x_default=None, col_y_default=None\n):\n    \"\"\"Calculate connections (node to node)\n\n    As this is already calculating the coordinates, we have to specify the columns that are used for the x and y axis. These coordinates should be numerical.\n\n    :param col_x_axis: name of the column to use for the x axis\n    :type col_x_axis: str\n    :param col_y_axis: name of the column to use for the y axis\n    :type col_y_axis: str\n    :param col_x_default: default value to use for the x axis, defaults to None\n    :type col_x_default: str, optional\n    :param col_y_default: default value to use for the y axis, defaults to None\n    :type col_y_default: str, optional\n    :return: list of connections\n    :rtype: list\n    \"\"\"\n\n    lut = self.lut\n    papers = self.papers\n\n    connection_data = [\n        [\n            (\n                lut[p[\"doi\"]].get(col_x_axis, col_x_default),\n                lut[p[\"doi\"]].get(col_y_axis, col_y_default),\n            ),\n            (\n                lut[pt_doi].get(col_x_axis, col_x_default),\n                lut[pt_doi].get(col_y_axis, col_y_default),\n            ),\n        ]\n        for p in papers\n        for pt_doi in p[self.connection_field_name]\n    ]\n    return connection_data\n</code></pre>"},{"location":"references/dataset/#kirsche.dataset.add_additional_data_to_papers","title":"<code>add_additional_data_to_papers(papers, extra_data, extra_data_use_keys)</code>","text":"<p>Enhance paper metadata using extra data</p> <p>Parameters:</p> Name Type Description Default <code>papers</code> <code>list</code> <p>list of paper metadata</p> required <code>extra_data</code> <code>dict</code> <p>extra data as a dictionary with keys as DOIs</p> required <code>extra_data_use_keys</code> <code>list</code> <p>list of keys to use from extra data</p> required <p>Returns:</p> Type Description <code>list</code> <p>enhanced list of papers</p> Source code in <code>kirsche/dataset.py</code> <pre><code>def add_additional_data_to_papers(papers, extra_data, extra_data_use_keys):\n    \"\"\"Enhance paper metadata using extra data\n\n    :param papers: list of paper metadata\n    :type papers: list\n    :param extra_data: extra data as a dictionary with keys as DOIs\n    :type extra_data: dict\n    :param extra_data_use_keys: list of keys to use from extra data\n    :type extra_data_use_keys: list\n    :return: enhanced list of papers\n    :rtype: list\n    \"\"\"\n    enhanced_papers = []\n    for p in papers:\n        p_extra_data = extra_data.get(p[\"doi\"].lower(), {})\n        if extra_data_use_keys is None:\n            extra_data_use_keys = p_extra_data.keys()\n\n        # Take only the required fields and values\n        p_extra_data = {\n            k: p_extra_data[k] for k in p_extra_data if k in extra_data_use_keys\n        }\n        p.update(p_extra_data)\n        enhanced_papers.append(p)\n\n    return enhanced_papers\n</code></pre>"},{"location":"references/dataset/#kirsche.dataset.format_authors","title":"<code>format_authors(paper)</code>","text":"<p>format_authors formats list of author fields to strings</p> <p>Parameters:</p> Name Type Description Default <code>paper</code> <code>dict</code> <p>dict of paper meta data</p> required <p>Returns:</p> Type Description <code>str</code> <p>string format of authors</p> Source code in <code>kirsche/dataset.py</code> <pre><code>def format_authors(paper):\n    \"\"\"\n    format_authors formats list of author fields to strings\n\n    :param paper: dict of paper meta data\n    :type paper: dict\n    :return: string format of authors\n    :rtype: str\n    \"\"\"\n    authors = paper[\"authors\"]\n    if len(authors) &gt; 2:\n        author = authors[0][\"name\"].split(\" \")[-1] + \" et al.\"\n    elif len(authors) == 2:\n        author = (\n            authors[0][\"name\"].split(\" \")[-1]\n            + \" &amp; \"\n            + authors[-1][\"name\"].split(\" \")[-1]\n        )\n    else:\n        author = authors[0][\"name\"].split(\" \")[-1]\n\n    year = f', {paper[\"year\"]}'\n\n    return author + year\n</code></pre>"},{"location":"references/download/","title":"Download","text":""},{"location":"references/download/#download","title":"download","text":""},{"location":"references/download/#kirsche.download.download_metadata","title":"<code>download_metadata(unique_ids, target=None, sleep_time=1)</code>","text":"<p>Download paper data</p> <p>Parameters:</p> Name Type Description Default <code>unique_ids</code> <code>list</code> <p>list of unique ids to find paper metadata</p> required <code>target</code> <code>Optional[Union[str, Path]]</code> <p>path to save data</p> <code>None</code> <code>sleep_time</code> <code>int</code> <p>time to sleep between requests, defaults to 1</p> <code>1</code> Source code in <code>kirsche/download.py</code> <pre><code>def download_metadata(\n    unique_ids: list, target: Optional[Union[str, Path]] = None, sleep_time: int = 1\n):\n    \"\"\"Download paper data\n\n    :param unique_ids: list of unique ids to find paper metadata\n    :param target: path to save data\n    :param sleep_time: time to sleep between requests, defaults to 1\n    \"\"\"\n\n    paper_info = []\n    fail_flag = 0\n    for doi in unique_ids:\n        logger.debug(f\"Getting info for {doi}\")\n        if fail_flag &lt;= 10:\n            try:\n                doi_paper_info = get_paper_info(doi)\n                paper_info.append(doi_paper_info)\n            except Exception as e:\n                logger.error(f\"{doi} failed: {e}\")\n                fail_flag += 1\n                continue\n        else:\n            logger.error(f\"Failed too many times downloading data... breaking out\")\n            break\n\n        time.sleep(sleep_time)\n\n    if target:\n        logger.debug(f\"Saving to {target}\")\n        save_batch_json(paper_info, target)\n        logger.debug(f\"Saved to {target}\")\n\n    return paper_info\n</code></pre>"},{"location":"references/download/#kirsche.download.list_dois","title":"<code>list_dois(paper_ids=None, bib_file=None)</code>","text":"<p>list_dois loads a list of DOIs from multiple possible sources</p> <p>Parameters:</p> Name Type Description Default <code>paper_ids</code> <code>Optional[Union[list, str]]</code> <p>list of DOIs</p> <code>None</code> <code>bib_file</code> <code>Optional[Union[str, Path]]</code> <p>path to bib file</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>list of DOIs loaded</p> Source code in <code>kirsche/download.py</code> <pre><code>def list_dois(\n    paper_ids: Optional[Union[list, str]] = None,\n    bib_file: Optional[Union[str, Path]] = None,\n) -&gt; list:\n    \"\"\"\n    list_dois loads a list of DOIs from multiple possible sources\n\n    :param paper_ids: list of DOIs\n    :param bib_file: path to bib file\n    :return: list of DOIs loaded\n    \"\"\"\n    if paper_ids:\n        logger.debug(f\"Using paper_ids directly...\")\n        if isinstance(paper_ids, str):\n            dois = [paper_ids]\n        else:\n            dois = paper_ids\n    elif bib_file:\n        dois = get_unique_ids_from_bib(bib_file)\n        logger.debug(f\"Retrieved {len(dois)} from {bib_file}\")\n    else:\n        logger.error(f\"Specify one of the DOI sources...\")\n        dois = []\n\n    logger.debug(f\"{(len(dois))} DOIs: {dois}\")\n\n    return dois\n</code></pre>"},{"location":"references/download/#kirsche.download.list_unique_ids","title":"<code>list_unique_ids(bib_file)</code>","text":"<p>list_unique_ids loads a list of unique ids from multiple possible sources</p> <p>Parameters:</p> Name Type Description Default <code>bib_file</code> <code>Union[str, Path]</code> <p>path to bib file</p> required <p>Returns:</p> Type Description <code>list</code> <p>list of unique ids loaded</p> Source code in <code>kirsche/download.py</code> <pre><code>def list_unique_ids(bib_file: Union[str, Path]) -&gt; list:\n    \"\"\"\n    list_unique_ids loads a list of unique ids from multiple possible sources\n\n    :param bib_file: path to bib file\n    :return: list of unique ids loaded\n    \"\"\"\n\n    unique_ids = get_unique_ids_from_bib(bib_file)\n    logger.debug(f\"Retrieved {len(unique_ids)} from {bib_file}\")\n\n    logger.debug(f\"{(len(unique_ids))} unique ids: {unique_ids}\")\n\n    return unique_ids\n</code></pre>"},{"location":"references/download/#kirsche.download.main","title":"<code>main(paper_id, bib_file, target, sleep_time)</code>","text":"<p>Download paper data from service provides (e.g., SemanticScholar)</p> Source code in <code>kirsche/download.py</code> <pre><code>@click.command()\n@click.option(\"--paper_id\", \"-p\", help=\"Paper ID\", multiple=True)\n@click.option(\"--bib_file\", \"-b\", help=\"Bib file path\")\n@click.option(\"--target\", \"-t\", help=\"Target data file path\")\n@click.option(\"--sleep_time\", \"-s\", default=1, help=\"Sleep time between requests\")\ndef main(paper_id, bib_file, target, sleep_time):\n    \"\"\"Download paper data from service provides (e.g., SemanticScholar)\"\"\"\n\n    if bib_file:\n        paper_id = list_unique_ids(bib_file)\n    elif isinstance(paper_id, str):\n        paper_id = [paper_id]\n\n    paper_info = download_metadata(paper_id, target, sleep_time)\n\n    return paper_info\n</code></pre>"},{"location":"references/visualize/","title":"Visualize","text":""},{"location":"references/visualize/#visualize","title":"visualize","text":""},{"location":"references/visualize/#kirsche.visualize.load_graph","title":"<code>load_graph(connections_json, title)</code>","text":"<p>Load json file that contains the paper connection information, and build a graph using it.</p> <p>Parameters:</p> Name Type Description Default <code>connections_json</code> <code>Union[str, Path]</code> <p>json file that contains the paper connection information</p> required <code>title</code> <code>str</code> <p>title of the graph which will be shown in the top of the chart</p> required Source code in <code>kirsche/visualize.py</code> <pre><code>def load_graph(connections_json: Union[str, Path], title: str) -&gt; PaperGraph:\n    \"\"\"Load json file that contains the paper connection information, and build a graph using it.\n\n    :param connections_json: json file that contains the paper connection information\n    :param title: title of the graph which will be shown in the top of the chart\n    \"\"\"\n\n    data = load_json(connections_json)\n\n    if data:\n        g = PaperGraph(data, title=title)\n    else:\n        raise ValueError(f\"No data in json file: {connections_json}!\")\n\n    return g\n</code></pre>"},{"location":"references/visualize/#kirsche.visualize.make_chart","title":"<code>make_chart(connections_json, target, title)</code>","text":"<p>Generate interactive graphs</p> <p>Parameters:</p> Name Type Description Default <code>connections_json</code> <code>Union[Path, str]</code> <p>json file that contains the paper connection information</p> required <code>target</code> <code>Union[Path, str]</code> <p>target file path</p> required <code>title</code> <code>str</code> <p>title of the graph which will be shown in the top of the chart</p> required Source code in <code>kirsche/visualize.py</code> <pre><code>def make_chart(\n    connections_json: Union[Path, str], target: Union[Path, str], title: str\n) -&gt; None:\n    \"\"\"Generate interactive graphs\n\n    :param connections_json: json file that contains the paper connection information\n    :param target: target file path\n    :param title: title of the graph which will be shown in the top of the chart\n    \"\"\"\n\n    g = load_graph(connections_json, title)\n\n    nodes = g.nodes\n    edges = g.edges\n\n    visualize(nodes, edges, g.title, target)\n</code></pre>"},{"location":"references/visualize/#kirsche.visualize.visualize","title":"<code>visualize(nodes, edges, title, target)</code>","text":"<p>Generate interactive graphs</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>nodes of the graph</p> required <code>edges</code> <code>list</code> <p>edges of the graph</p> required <code>title</code> <code>str</code> <p>title of the graph which will be shown in the top of the chart</p> required <code>target</code> <code>Union[str, Path]</code> <p>target file path</p> required Source code in <code>kirsche/visualize.py</code> <pre><code>def visualize(nodes: list, edges: list, title: str, target: Union[str, Path]) -&gt; None:\n    \"\"\"Generate interactive graphs\n\n    :param nodes: nodes of the graph\n    :param edges: edges of the graph\n    :param title: title of the graph which will be shown in the top of the chart\n    :param target: target file path\n    \"\"\"\n\n    if isinstance(target, str):\n        target = Path(target)\n\n    if not target.parent.exists():\n        target.parent.mkdir(parents=True)\n\n    # Build the graph and export it to html file\n    (\n        Graph(init_opts=opts.InitOpts(width=\"1600px\", height=\"800px\", page_title=title))\n        .add(\n            series_name=\"\",\n            nodes=nodes,\n            links=edges,\n            layout=\"none\",\n            is_roam=True,\n            is_focusnode=True,\n            label_opts=opts.LabelOpts(is_show=False),\n            linestyle_opts=opts.LineStyleOpts(width=10, curve=0.3, opacity=0.5),\n        )\n        .set_global_opts(title_opts=opts.TitleOpts(title=title))\n        .render(target)\n    )\n</code></pre>"},{"location":"references/utils/","title":"Index","text":""},{"location":"references/utils/#utils","title":"Utils","text":"<p><code>kirsche.utils</code> module contains the utilities.</p>"},{"location":"references/utils/bib/","title":"utils.bib","text":""},{"location":"references/utils/bib/#utils-bib","title":"Utils - bib","text":""},{"location":"references/utils/bib/#kirsche.utils.bib.get_dois_from_bib","title":"<code>get_dois_from_bib(bib_file)</code>","text":"<p>[Deprecated] use get_unique_ids_from_bib instead.</p> <p>get_dois_from_bib returns a list of DOIs from a bib file</p> <p>Parameters:</p> Name Type Description Default <code>bib_file</code> <code>Union[str, Path]</code> <p>path to bib file</p> required <p>Returns:</p> Type Description <code>list</code> <p>list of DOIs</p> Source code in <code>kirsche/utils/bib.py</code> <pre><code>def get_dois_from_bib(bib_file: Union[str, Path]) -&gt; list:\n    \"\"\"\n    [Deprecated] use get_unique_ids_from_bib instead.\n\n    get_dois_from_bib returns a list of DOIs from a bib file\n\n    :param bib_file: path to bib file\n    :return: list of DOIs\n    \"\"\"\n\n    return get_unique_ids_from_bib(bib_file, key=\"doi\")\n</code></pre>"},{"location":"references/utils/bib/#kirsche.utils.bib.get_dois_from_bib_re","title":"<code>get_dois_from_bib_re(bib_file)</code>","text":"<p>Retrieve DOIs by parsing bib file line by line.</p> Source code in <code>kirsche/utils/bib.py</code> <pre><code>def get_dois_from_bib_re(bib_file: Union[str, Path]) -&gt; list:\n    \"\"\"Retrieve DOIs by parsing bib file line by line.\"\"\"\n\n    with open(bib_file, \"r\") as bibtex_file:\n        data = bibtex_file.readlines()\n\n    re_doi = re.compile(r\"^doi\\s=\\s\\{(?P&lt;doi&gt;.+)\\}\")\n\n    dois = [re_doi.search(i.strip()) for i in data]\n    dois = [i.group(\"doi\") for i in dois if i is not None]\n\n    return dois\n</code></pre>"},{"location":"references/utils/bib/#kirsche.utils.bib.get_unique_ids_from_bib","title":"<code>get_unique_ids_from_bib(bib_file, keys=None, unique_id_prefix=None)</code>","text":"<p>get_unique_ids_from_bib returns a list of unique IDs from a bib file for a given key or list of keys.</p> <p>By default, the key is \"doi\". It can also be - arxivid, which can return values like arXiv:0804.4726 - pmid, which can return values like PMID:26017442.</p> <p>keys can also be a list of keys to check in order of priority, e.g., <code>[\"doi\", \"arxivid\", \"pmid\"]</code>.</p> <p>For each record, we will look up the paper based on the order of the list. If doi exists, the functioin will use doi and start the next record. If doi is not found, the function will use arxivid for the same record.</p> <p>If only one value in keys is specified, we will the same key specified for all records.</p> <p>Parameters:</p> Name Type Description Default <code>bib_file</code> <code>Union[str, Path]</code> <p>path to bib file</p> required <code>keys</code> <code>Optional[Union[str, list]]</code> <p>key to use to find unique ids in the bib data, default is doi.</p> <code>None</code> <code>unique_id_prefix</code> <code>dict</code> <p>prefix to use for unique ids</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>list of DOIs</p> Source code in <code>kirsche/utils/bib.py</code> <pre><code>def get_unique_ids_from_bib(\n    bib_file: Union[str, Path],\n    keys: Optional[Union[str, list]] = None,\n    unique_id_prefix: dict = None,\n) -&gt; list:\n    \"\"\"\n    get_unique_ids_from_bib returns a list of unique IDs from a bib file for a given key or list of keys.\n\n    By default, the key is \"doi\". It can also be\n    - arxivid, which can return values like arXiv:0804.4726\n    - pmid, which can return values like PMID:26017442.\n\n    keys can also be a list of keys to check in order of priority, e.g., `[\"doi\", \"arxivid\", \"pmid\"]`.\n\n    For each record, we will look up the paper based on the order of the list. If doi exists, the functioin will use doi and start the next record. If doi is not found, the function will use arxivid for the same record.\n\n    If only one value in keys is specified, we will the same key specified for all records.\n\n    :param bib_file: path to bib file\n    :param keys: key to use to find unique ids in the bib data, default is doi.\n    :param unique_id_prefix: prefix to use for unique ids\n    :return: list of DOIs\n    \"\"\"\n    if keys is None:\n        keys = UNIQUE_ID_PRECEDENCE\n    elif isinstance(keys, str):\n        keys = [keys]\n\n    if unique_id_prefix is None:\n        unique_id_prefix = UNIQUE_ID_PREFIX\n\n    bib_data = load_bib(bib_file)\n\n    if keys:\n        ids = parse_unique_ids_by_keys(bib_data, keys, unique_id_prefix)\n    else:\n        raise ValueError(\"key or key_precedence must be specified\")\n\n    return ids\n</code></pre>"},{"location":"references/utils/bib/#kirsche.utils.bib.load_bib","title":"<code>load_bib(bib_file)</code>","text":"<p>Load bib content from bib files</p> Source code in <code>kirsche/utils/bib.py</code> <pre><code>def load_bib(bib_file: Union[str, Path]) -&gt; list:\n    \"\"\"Load bib content from bib files\"\"\"\n\n    if isinstance(bib_file, str):\n        bib_file = Path(bib_file)\n\n    if not bib_file.exists():\n        raise FileNotFoundError(f\"{bib_file} does not exist\")\n\n    with open(bib_file, \"r\") as bibtex_file:\n        parser = BibTexParser(common_strings=True)\n        parser.customization = convert_to_unicode\n        bib_database = bibtexparser.load(bibtex_file, parser=parser)\n\n    return bib_database.entries\n</code></pre>"},{"location":"references/utils/bib/#kirsche.utils.bib.parse_unique_ids_by_keys","title":"<code>parse_unique_ids_by_keys(bib_data, keys, unique_id_prefix)</code>","text":"<p>parse_unique_ids_by_keys parses bib data based on keys.</p> <p>Parameters:</p> Name Type Description Default <code>bib_data</code> <code>list</code> <p>list of bib records loaded from a bib file</p> required <code>keys</code> <code>Union[str, list]</code> <p>list of keys as the lookup order, e.g., [\"doi\", \"arxivid\", \"pmid\"]</p> required <code>unique_id_prefix</code> <code>dict</code> <p>a dictionary to specify what prefix to use for each key</p> required Source code in <code>kirsche/utils/bib.py</code> <pre><code>def parse_unique_ids_by_keys(\n    bib_data: list, keys: Union[str, list], unique_id_prefix: dict\n) -&gt; list:\n    \"\"\"\n    parse_unique_ids_by_keys parses bib data based on keys.\n\n    :param bib_data: list of bib records loaded from a bib file\n    :param keys: list of keys as the lookup order, e.g., [\"doi\", \"arxivid\", \"pmid\"]\n    :param unique_id_prefix: a dictionary to specify what prefix to use for each key\n    \"\"\"\n\n    ids = []\n    for i in bib_data:\n        i_unique_id = \"\"\n        for k in keys:\n            k_prefix = unique_id_prefix.get(k, \"\")\n            i_k_value = i.get(k, \"\")\n            # We do not need the version in the arxivids\n            if k == \"arxivid\":\n                i_k_value = i_k_value.split(\"v\")[0]\n            if i_k_value:\n                i_unique_id = f\"{k_prefix}{i_k_value}\"\n                break\n        ids.append(i_unique_id)\n\n    return ids\n</code></pre>"},{"location":"references/utils/io/","title":"utils.io","text":""},{"location":"references/utils/io/#utils-io","title":"Utils - io","text":""},{"location":"references/utils/io/#kirsche.utils.io.is_dir","title":"<code>is_dir(path)</code>","text":"<p>Check if the given path is a directory</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to be checked</p> required Source code in <code>kirsche/utils/io.py</code> <pre><code>def is_dir(path: Union[str, Path]) -&gt; bool:\n    \"\"\"Check if the given path is a directory\n\n    :param path: path to be checked\n    \"\"\"\n    if isinstance(path, str):\n        path = Path(path)\n\n    if path.exists():\n        return path.is_dir()\n    else:\n        return str(path).endswith(\"/\")\n</code></pre>"},{"location":"references/utils/io/#kirsche.utils.io.load_batch_json","title":"<code>load_batch_json(data_path)</code>","text":"<p>load data from json file(s)</p> <p>If the given <code>data_path</code> is a folder, all the json files in the folder are loaded. If the given <code>data_path</code> is a single json file, everything inside the file will be loaded.</p> <p>Parameters:</p> Name Type Description Default <code>data_path</code> <code>Union[str, Path]</code> <p>json file path</p> required Source code in <code>kirsche/utils/io.py</code> <pre><code>def load_batch_json(data_path: Union[str, Path]) -&gt; Union[dict, list]:\n    \"\"\"load data from json file(s)\n\n    If the given `data_path` is a folder, all the json files in the folder are loaded. If the given `data_path` is a single json file, everything inside the file will be loaded.\n\n    :param data_path: json file path\n    \"\"\"\n    if isinstance(data_path, str):\n        data_path = Path(data_path)\n\n    if not data_path.exists():\n        return []\n\n    if data_path.is_dir():\n        logger.debug(f\"loading all data files from {data_path} folder\")\n        data_path_all_json = list(data_path.glob(\"*.json\"))\n        logger.debug(f\"Found {len(data_path_all_json)} json files in {data_path}.\")\n        data = []\n        for data_file in data_path_all_json:\n            logger.debug(f\"loading data from {data_file}\")\n            data.append(load_json(data_file))\n    elif data_path.is_file():\n        logger.debug(f\"loading data from a single file {data_path}\")\n        data = load_json(data_path)\n\n    return data\n</code></pre>"},{"location":"references/utils/io/#kirsche.utils.io.load_json","title":"<code>load_json(data_file)</code>","text":"<p>load dict/list of dict data from json file</p> <p>Parameters:</p> Name Type Description Default <code>data_file</code> <code>Union[str, Path]</code> <p>json file path</p> required Source code in <code>kirsche/utils/io.py</code> <pre><code>def load_json(data_file: Union[str, Path]) -&gt; dict:\n    \"\"\"load dict/list of dict data from json file\n\n    :param data_file: json file path\n    \"\"\"\n    if isinstance(data_file, str):\n        data_file = Path(data_file)\n    if not data_file.exists():\n        raise Exception(f\"File not found: {data_file}\")\n\n    logger.debug(f\"loading data from {data_file}\")\n    with open(data_file, \"r\") as f:\n        data = json.load(f)\n\n    return data.copy()\n</code></pre>"},{"location":"references/utils/io/#kirsche.utils.io.record_exists","title":"<code>record_exists(id, existing_records, keys=UNIQUE_ID_PRECEDENCE, unique_id_prefix=UNIQUE_ID_PREFIX)</code>","text":"<p>Whether the record already exists in the data file</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>json files folder path</p> required Source code in <code>kirsche/utils/io.py</code> <pre><code>def record_exists(\n    id,\n    existing_records: list,\n    keys: list = UNIQUE_ID_PRECEDENCE,\n    unique_id_prefix: list = UNIQUE_ID_PREFIX,\n) -&gt; bool:\n    \"\"\"Whether the record already exists in the data file\n\n    :param id: json files folder path\n    \"\"\"\n\n    if keys is None:\n        keys = UNIQUE_ID_PRECEDENCE\n    if unique_id_prefix is None:\n        unique_id_prefix = UNIQUE_ID_PREFIX\n\n    # The keys are most likely to have prefixes, e.g., arXiv:, PMID:\n    # we need to strip them out before checking if the record exists\n    cleansing_id = id\n    for k, v in unique_id_prefix.items():\n        if id.startswith(v):\n            cleansing_id = id.replace(v, \"\")\n            break\n\n    # set default value to False as this is more acceptable in most cases\n    # if we missed something in the lookup, we will redownload the data\n    # if we use False as default. This is no big deal.\n    # Otherwise, we might miss some data.\n    exists = False\n\n    for record in existing_records:\n        for k in keys:\n            k_value = record.get(k, \"\")\n            if k_value is None:\n                continue\n            elif k_value.lower() == cleansing_id.lower():\n                return True\n\n    return exists\n</code></pre>"},{"location":"references/utils/io/#kirsche.utils.io.save_batch_json","title":"<code>save_batch_json(records, data_path, unique_key=None, mode=None)</code>","text":"<p>save data to json file.</p> <p>There are two modes: - single file mode, if the <code>data_path</code> is a folder, and - multi file mode, if the <code>data_path</code> is a json file path.</p> <p>In the single file mode, all the entries in the data are saved to the same file. In the multi file mode, each entry will be saved as a separate file.</p> <p>Single file mode is good for long term presevation, and multi file mode is good for updates.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>list</code> <p>list of data to be saved</p> required <code>data_path</code> <code>Union[str, Path]</code> <p>json file path or folder path</p> required Source code in <code>kirsche/utils/io.py</code> <pre><code>def save_batch_json(records: list, data_path: Union[str, Path], unique_key=None, mode=None) -&gt; None:\n    \"\"\"save data to json file.\n\n    There are two modes:\n    - single file mode, if the `data_path` is a folder, and\n    - multi file mode, if the `data_path` is a json file path.\n\n    In the single file mode, all the entries in the data are saved to the same file. In the multi file mode, each entry will be saved as a separate file.\n\n    Single file mode is good for long term presevation, and multi file mode is good for updates.\n\n    :param records: list of data to be saved\n    :param data_path: json file path or folder path\n    \"\"\"\n    if isinstance(data_path, str):\n        data_path = Path(data_path)\n\n    if not data_path.exists():\n        if str(data_path).endswith(\".json\"):\n            mode = \"single\"\n        else:\n            mode = \"multi\"\n\n    if unique_key is None:\n        unique_key = \"corpusId\"\n\n    if data_path.is_dir() or (mode == \"multi\"):\n        if not data_path.exists():\n            data_path.mkdir(parents=True)\n        logger.debug(f\"saving all data records to {data_path} folder\")\n        data_path_all_json = list(data_path.glob(\"*.json\"))\n        logger.debug(f\"Found {len(data_path_all_json)} json files in {data_path}.\")\n        data = []\n        for record in records:\n            # Construct path\n            try:\n                unique_key_value = record[unique_key]\n            except KeyError:\n                logger.error(f\"{unique_key} not found in {record}\")\n                continue\n\n            data_file = data_path / f\"{unique_key_value}.json\"\n            logger.debug(f\"saving data to {data_file}\")\n            save_json(record, data_file)\n\n    else:\n        logger.debug(f\"loading data from a single file {data_path}\")\n        save_json(records, data_path)\n</code></pre>"},{"location":"references/utils/io/#kirsche.utils.io.save_json","title":"<code>save_json(data, data_file)</code>","text":"<p>save data to json file</p> <p>This Function Overwrites any Existing Content</p> <p>Beware that all contents in the file will be overwritten if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[dict, list]</code> <p>dictionary data to be saved</p> required <code>data_file</code> <code>Union[str, Path]</code> <p>json file path</p> required Source code in <code>kirsche/utils/io.py</code> <pre><code>def save_json(data: Union[dict, list], data_file: Union[str, Path]) -&gt; None:\n    \"\"\"save data to json file\n\n    !!! warning \"This Function Overwrites any Existing Content\"\n        Beware that all contents in the file will be overwritten if it exists.\n\n    :param data: dictionary data to be saved\n    :param data_file: json file path\n    \"\"\"\n    if isinstance(data_file, str):\n        data_file = Path(data_file)\n    if data_file.exists():\n        logger.warning(f\"{data_file} exists! Will replace the content\")\n\n    logger.debug(f\"saving data to {data_file}\")\n    with open(data_file, \"w\") as f:\n        json.dump(data, f, indent=4)\n</code></pre>"},{"location":"references/utils/semanticscholar/","title":"utils.semanticscholar","text":""},{"location":"references/utils/semanticscholar/#utils-semanticscholar","title":"Utils - semanticscholar","text":""},{"location":"references/utils/semanticscholar/#kirsche.utils.semanticscholar.get_paper_info","title":"<code>get_paper_info(paper_id, API_BASE=None)</code>","text":"<p>Get paper info from Semantic Scholar API</p> <p>Parameters:</p> Name Type Description Default <code>paper_id</code> <code>list</code> <p>list of paper ids</p> required <code>API_BASE</code> <p>base url for the API, default is semanticscholar</p> <code>None</code> Source code in <code>kirsche/utils/semanticscholar.py</code> <pre><code>def get_paper_info(paper_id: list, API_BASE=None) -&gt; list:\n    \"\"\"\n    Get paper info from Semantic Scholar API\n\n    :param paper_id: list of paper ids\n    :param API_BASE: base url for the API, default is semanticscholar\n    \"\"\"\n    if API_BASE is None:\n        API_BASE = \"https://api.semanticscholar.org/v1/paper/\"\n\n    logger.debug(f\"Getting paper info using base URL {paper_id}\")\n\n    # Get paper info from Semantic Scholar API\n    url = API_BASE + paper_id\n\n    test_content = get_page_content(url)\n\n    if test_content[\"status\"] != 200:\n        raise Exception(\n            f\"Error: Semantic Scholar API returned status code {test_content['status']}\"\n        )\n    else:\n        paper_info = json.loads(test_content[\"content\"].text)\n        return paper_info\n</code></pre>"},{"location":"references/utils/web/","title":"utils.web","text":""},{"location":"references/utils/web/#utils-web","title":"Utils - web","text":""},{"location":"references/utils/web/#kirsche.utils.web.get_page_content","title":"<code>get_page_content(link, session=None, session_query_configs=None, method='GET', data=None)</code>","text":"<p>Download page and save content</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>link to get content from</p> required <code>session</code> <code>Optional[Session]</code> <p>requests session object, defaults to a new session</p> <code>None</code> <code>session_query_configs</code> <code>Optional[dict]</code> <p>session query configs, defaults to get_session_query_configs</p> <code>None</code> <code>method</code> <code>Optional[str]</code> <p>method to use, defaults to \"GET\"</p> <code>'GET'</code> <code>data</code> <code>Optional[dict]</code> <p>data to send with the request, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <p>page content data</p> Source code in <code>kirsche/utils/web.py</code> <pre><code>def get_page_content(\n    link: str,\n    session: Optional[requests.Session] = None,\n    session_query_configs: Optional[dict] = None,\n    method: Optional[str] = \"GET\",\n    data: Optional[dict] = None,\n):\n    \"\"\"Download page and save content\n\n    :param link: link to get content from\n    :param session: requests session object, defaults to a new session\n    :param session_query_configs: session query configs, defaults to get_session_query_configs\n    :param method: method to use, defaults to \"GET\"\n    :param data: data to send with the request, defaults to None\n    :return: page content data\n    \"\"\"\n\n    if not session_query_configs:\n        session_query_configs = get_session_query_configs()\n\n    if not session:\n        session = get_session(\n            retry_params=None,\n            session=None,\n        )\n    if method == \"GET\":\n        content = session.get(link, **session_query_configs)\n    elif method == \"POST\":\n        if data is None:\n            data = {}\n        content = session.post(link, data=data, **session_query_configs)\n\n    status = content.status_code\n\n    return {\"status\": status, \"content\": content}\n</code></pre>"},{"location":"references/utils/web/#kirsche.utils.web.get_random_user_agent","title":"<code>get_random_user_agent(browsers=None)</code>","text":"<p>get_random_user_agent returns a random user agent. We provide two predefined browers, chrome and firefox.</p> <p>Parameters:</p> Name Type Description Default <code>browsers</code> <code>Optional[Union[str, list]]</code> <p>which brower to be used, defaults to [\"chrome\", \"firefox\"]</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>dictionary for requests module to consude as {'User-Agent': \"blabla\"}</p> Source code in <code>kirsche/utils/web.py</code> <pre><code>def get_random_user_agent(browsers: Optional[Union[str, list]] = None) -&gt; dict:\n    \"\"\"\n    get_random_user_agent returns a random user agent.\n    We provide two predefined browers, chrome and firefox.\n\n    :param browsers: which brower to be used, defaults to [\"chrome\", \"firefox\"]\n    :return: dictionary for requests module to consude as {'User-Agent': \"blabla\"}\n    \"\"\"\n\n    if browsers is None:\n        browsers = [\"chrome\", \"firefox\"]\n    if isinstance(browsers, str):\n        browsers = [browsers]\n\n    chrome_user_agents = [\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.157 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36\",\n    ]\n    firefox_user_agents = [\n        \"Mozilla/4.0 (compatible; MSIE 9.0; Windows NT 6.1)\",\n        \"Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)\",\n        \"Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (Windows NT 6.2; WOW64; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0; Trident/5.0)\",\n        \"Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)\",\n        \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0)\",\n        \"Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)\",\n        \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\",\n    ]\n\n    user_agents_dict = {\"chrome\": chrome_user_agents, \"firefox\": firefox_user_agents}\n\n    # error if specified browser is not in the list\n    if set(browsers) - set(user_agents_dict.keys()):\n        logger.error(f\"Unknown browser: {set(browsers) - set(user_agents_dict.keys())}\")\n\n    user_agent_list = sum([user_agents_dict[browser] for browser in browsers], [])\n\n    return {\"User-Agent\": random.choice(user_agent_list)}\n</code></pre>"},{"location":"references/utils/web/#kirsche.utils.web.get_session","title":"<code>get_session(retry_params={'retries': 5, 'backoff_factor': 0.3, 'status_forcelist': (500, 502, 504)}, session=None)</code>","text":"<p>get_session prepares a session object.</p> <p>Parameters:</p> Name Type Description Default <code>retry_params</code> <code>Optional[dict]</code> <p>the rules to retry, defaults to {\"retries\": 5, \"backoff_factor\": 0.3, \"status_forcelist\": (500, 502, 504)}</p> <code>{'retries': 5, 'backoff_factor': 0.3, 'status_forcelist': (500, 502, 504)}</code> <code>session</code> <code>Optional[Session]</code> <p>a requests session object to be used to query, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>Session</code> <p>a requests session object</p> Source code in <code>kirsche/utils/web.py</code> <pre><code>def get_session(\n    retry_params: Optional[dict] = {\n        \"retries\": 5,\n        \"backoff_factor\": 0.3,\n        \"status_forcelist\": (500, 502, 504),\n    },\n    session: Optional[requests.Session] = None,\n) -&gt; requests.Session:\n    \"\"\"\n    get_session prepares a session object.\n\n    :param retry_params: the rules to retry, defaults to {\"retries\": 5, \"backoff_factor\": 0.3, \"status_forcelist\": (500, 502, 504)}\n    :param session: a requests session object to be used to query, defaults to None\n    :return: a requests session object\n    \"\"\"\n\n    if retry_params is None:\n        retry_params = {\n            \"retries\": 5,\n            \"backoff_factor\": 0.3,\n            \"status_forcelist\": (500, 502, 504),\n        }\n\n    if session is None:\n        session = requests.Session()\n\n    retry = Retry(\n        total=retry_params.get(\"retries\"),\n        read=retry_params.get(\"retries\"),\n        connect=retry_params.get(\"retries\"),\n        backoff_factor=retry_params.get(\"backoff_factor\"),\n        status_forcelist=retry_params.get(\"status_forcelist\"),\n    )\n\n    adapter = HTTPAdapter(max_retries=retry)\n    session.mount(\"http://\", adapter)\n    session.mount(\"https://\", adapter)\n\n    return session\n</code></pre>"},{"location":"references/utils/web/#kirsche.utils.web.get_session_query_configs","title":"<code>get_session_query_configs(headers=None, timeout=(5, 14), proxies={}, cookies={'language': 'en'})</code>","text":"<p>get_session_query_configs creates a session config dictionary for session to use. These are the keyword arguments of the session get or post methods. Proxies can be set by providing a dictionary of the form <pre><code>{\n    'http': some super_proxy_url,\n    'https': some super_proxy_url,\n}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Optional[dict]</code> <p>header of the method such as use agent, defaults to random user agent from get_random_user_agent</p> <code>None</code> <code>timeout</code> <code>Optional[list]</code> <p>timeout strategy, defaults to (5, 14)</p> <code>(5, 14)</code> <code>proxies</code> <code>Optional[dict]</code> <p>proxy configs, defaults to {}</p> <code>{}</code> <code>cookies</code> <code>Optional[dict]</code> <p>cookie configs, defaults to {\"language\": \"en\"}</p> <code>{'language': 'en'}</code> <p>Returns:</p> Type Description <code>dict</code> <p>dictionary of session configs for session methods, e.g., get, to use.</p> Source code in <code>kirsche/utils/web.py</code> <pre><code>def get_session_query_configs(\n    headers: Optional[dict] = None,\n    timeout: Optional[list] = (5, 14),\n    proxies: Optional[dict] = {},\n    cookies: Optional[dict] = {\"language\": \"en\"},\n) -&gt; dict:\n    \"\"\"\n    get_session_query_configs creates a session config dictionary for session to use. These are the keyword arguments of the session get or post methods.\n    Proxies can be set by providing a dictionary of the form\n    ```python\n    {\n        'http': some super_proxy_url,\n        'https': some super_proxy_url,\n    }\n    ```\n    :param headers: header of the method such as use agent, defaults to random user agent from get_random_user_agent\n    :param timeout: timeout strategy, defaults to (5, 14)\n    :param proxies: proxy configs, defaults to {}\n    :param cookies: cookie configs, defaults to {\"language\": \"en\"}\n    :return: dictionary of session configs for session methods, e.g., get, to use.\n    \"\"\"\n\n    if cookies is None:\n        cookies = {\"language\": \"en\"}\n\n    if headers is None:\n        headers = get_random_user_agent()\n\n    if os.getenv(\"SC_API_KEY\") and \"x-api-key\" not in headers:\n        headers[\"x-api-key\"] = os.getenv(\"SC_API_KEY\")\n\n    if timeout is None:\n        timeout = (5, 14)\n\n    if proxies is None:\n        proxies = {}\n\n    return dict(headers=headers, proxies=proxies, cookies=cookies)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#tutorials","title":"Tutorials","text":"<p>The easiest way to use Kirsche is through the command line tool.</p> <p>Kirsche in your script</p> <p>Kirsche also works as a proper Python package. See this tutorials for more.</p>"},{"location":"tutorials/#install","title":"Install","text":"<pre><code>pip install kirsche\n</code></pre> Install in an Environment <p>Unless you are using this in a temporary machine like a docker container, it is recommended to install this in an environment.</p> <p>For example, using conda, we can create an environment called <code>kirsche</code> or any other name you prefer,</p> <pre><code>conda create -n \"kirsche\" python=3.8 pip\n</code></pre> <p>then activate the environment</p> <pre><code>conda activate kirsche\n</code></pre> <p>Install kirsche in this environment</p> <pre><code>pip install kirsche\n</code></pre>"},{"location":"tutorials/#download-metadata-of-papers","title":"Download Metadata of Papers","text":"<p>Kirsche downloads metadata about the given papers. The papers can be provided through a bib file or simply through an option to the command line.</p>"},{"location":"tutorials/#using-dois","title":"Using DOIs","text":"<pre><code>kirsche metadata -p \"10.1016/j.sna.2020.112529\" -p \"10.1152/jn.00208.2014\"\n</code></pre> <p>The above command will print out the metadata in the command line.</p> <p>To save the results as a file, specify the path through the <code>-tm</code> option:</p> <pre><code>kirsche metadata -p \"10.1016/j.sna.2020.112529\" -p \"10.1152/jn.00208.2014\" -t paper_metadata.json\n</code></pre> <p>The above command saves the metadata of the papers in <code>paper_metadata.json</code>. Please choose a path that is suitable for you.</p> An Example of the Output File <p>The file <code>paper_metadata.json</code> will look like the following.</p> <pre><code>[\n    {\n        \"abstract\": \"Despite compelling phenomenological evidence that small electric fields (&lt;5 mV/mm) can affect brain function, a quantitative and experimentally verified theory is currently lacking. Here we demonstrate a novel mechanism by which the nonlinear properties of single neurons \\u201camplify\\u201d the effect of small electric fields: when concurrent to suprathreshold synaptic input, small electric fields can have significant effects on spike timing. For low-frequency fields, our theory predicts a linear dependency of spike timing changes on field strength. For high-frequency fields (relative to the synaptic input), the theory predicts coherent firing, with mean firing phase and coherence each increasing monotonically with field strength. Importantly, in both cases, the effects of fields on spike timing are amplified with decreasing synaptic input slope and increased cell susceptibility (millivolt membrane polarization per field amplitude). We confirmed these predictions experimentally using CA1 hippocampal neurons in vitro exposed to static (direct current) and oscillating (alternating current) uniform electric fields. In addition, we develop a robust method to quantify cell susceptibility using spike timing. Our results provide a precise mechanism for a functional role of endogenous field oscillations (e.g., gamma) in brain function and introduce a framework for considering the effects of environmental fields and design of low-intensity therapeutic neurostimulation technologies.\",\n        \"arxivId\": null,\n        \"authors\": [\n            {\n                \"authorId\": \"2433485\",\n                \"name\": \"T. Radman\",\n                \"url\": \"https://www.semanticscholar.org/author/2433485\"\n            },\n            {\n                \"authorId\": \"2171101564\",\n                \"name\": \"Yuzhuo Su\",\n                \"url\": \"https://www.semanticscholar.org/author/2171101564\"\n            },\n            {\n                \"authorId\": \"49211962\",\n                \"name\": \"Je Hi An\",\n                \"url\": \"https://www.semanticscholar.org/author/49211962\"\n            },\n            {\n                \"authorId\": \"2583773\",\n                \"name\": \"L. Parra\",\n                \"url\": \"https://www.semanticscholar.org/author/2583773\"\n            },\n            {\n                \"authorId\": \"2589386\",\n                \"name\": \"M. Bikson\",\n                \"url\": \"https://www.semanticscholar.org/author/2589386\"\n            }\n        ],\n        \"citationVelocity\": 12,\n        \"citations\": [\n            {\n                \"arxivId\": null,\n                \"authors\": [\n                    {\n                        \"authorId\": \"1753686931\",\n                        \"name\": \"Adri\\u00e0 Galan-Gadea\"\n                    },\n                    {\n                        \"authorId\": \"144302802\",\n                        \"name\": \"R. Salvador\"\n                    },\n                    {\n                        \"authorId\": \"2125273592\",\n                        \"name\": \"F. Bartolomei\"\n                    },\n                    {\n                        \"authorId\": \"7992816\",\n                        \"name\": \"F. Wendling\"\n                    },\n                    {\n                        \"authorId\": \"144679534\",\n                        \"name\": \"G. Ruffini\"\n                    }\n                ],\n                \"doi\": \"10.1101/2022.07.19.500653\",\n                \"intent\": [\n                    \"background\"\n                ],\n                \"isInfluential\": false,\n                \"paperId\": \"aa4c53bd984e73fadf57f61c8d130a7754d662e3\",\n                \"title\": \"Spherical harmonics representation of the steady-state membrane potential shift induced by tDCS in realistic neuron models\",\n                \"url\": \"https://www.semanticscholar.org/paper/aa4c53bd984e73fadf57f61c8d130a7754d662e3\",\n                \"venue\": \"bioRxiv\",\n                \"year\": 2022\n            },\n            // ... There are many more but we only list one here as an example\n        ],\n        \"corpusId\": 1314383,\n        \"doi\": \"10.1523/JNEUROSCI.0095-07.2007\",\n        \"fieldsOfStudy\": [\n            \"Physics\",\n            \"Medicine\"\n        ],\n        \"influentialCitationCount\": 18,\n        \"isOpenAccess\": true,\n        \"isPublisherLicensed\": true,\n        \"is_open_access\": true,\n        \"is_publisher_licensed\": true,\n        \"numCitedBy\": 225,\n        \"numCiting\": 62,\n        \"paperId\": \"b7c917cc3e489a3af40270dcba6dbf3bd2ebadf7\",\n        \"references\": [\n            {\n                \"arxivId\": null,\n                \"authors\": [\n                    {\n                        \"authorId\": \"48950990\",\n                        \"name\": \"B. Nolan\"\n                    }\n                ],\n                \"doi\": \"10.1016/S0513-5117(08)79025-2\",\n                \"intent\": [\n                    \"background\"\n                ],\n                \"isInfluential\": true,\n                \"paperId\": \"23a29ca37d7f5e0cd771ea5441ff625a4db9d399\",\n                \"title\": \"Boosting slow oscillations during sleep potentiates memory\",\n                \"url\": \"https://www.semanticscholar.org/paper/23a29ca37d7f5e0cd771ea5441ff625a4db9d399\",\n                \"venue\": \"\",\n                \"year\": 2008\n            },\n            // ... omitted some of the references\n        ],\n        \"s2FieldsOfStudy\": [\n            {\n                \"category\": \"Physics\",\n                \"source\": \"external\"\n            },\n            {\n                \"category\": \"Medicine\",\n                \"source\": \"external\"\n            },\n            {\n                \"category\": \"Biology\",\n                \"source\": \"s2-fos-model\"\n            }\n        ],\n        \"title\": \"Spike Timing Amplifies the Effect of Electric Fields on Neurons: Implications for Endogenous Field Effects\",\n        \"topics\": [\n            {\n                \"topic\": \"electric field\",\n                \"topicId\": \"5788\",\n                \"url\": \"https://www.semanticscholar.org/topic/5788\"\n            },\n            {\n                \"topic\": \"Hippocampus (Brain)\",\n                \"topicId\": \"1384\",\n                \"url\": \"https://www.semanticscholar.org/topic/1384\"\n            },\n            {\n                \"topic\": \"In Vitro [Publication Type]\",\n                \"topicId\": \"148897\",\n                \"url\": \"https://www.semanticscholar.org/topic/148897\"\n            },\n            {\n                \"topic\": \"neurostimulation\",\n                \"topicId\": \"84054\",\n                \"url\": \"https://www.semanticscholar.org/topic/84054\"\n            },\n            {\n                \"topic\": \"millivolt\",\n                \"topicId\": \"324943\",\n                \"url\": \"https://www.semanticscholar.org/topic/324943\"\n            },\n            {\n                \"topic\": \"CA1 field\",\n                \"topicId\": \"1381\",\n                \"url\": \"https://www.semanticscholar.org/topic/1381\"\n            },\n            {\n                \"topic\": \"emotional dependency\",\n                \"topicId\": \"2851\",\n                \"url\": \"https://www.semanticscholar.org/topic/2851\"\n            },\n            {\n                \"topic\": \"Tissue membrane\",\n                \"topicId\": \"1269\",\n                \"url\": \"https://www.semanticscholar.org/topic/1269\"\n            }\n        ],\n        \"url\": \"https://www.semanticscholar.org/paper/b7c917cc3e489a3af40270dcba6dbf3bd2ebadf7\",\n        \"venue\": \"Journal of Neuroscience\",\n        \"year\": 2007\n    }\n]\n</code></pre>"},{"location":"tutorials/#using-a-bib-file","title":"Using a bib file","text":"<pre><code>kirsche metadata -bib path/to/your/bib/file.bib -t save/to/file/path.json\n</code></pre>"},{"location":"tutorials/#download-and-calculate-connections","title":"Download and Calculate Connections","text":"<p>Kirsche can also calculate the connections between papers.</p>"},{"location":"tutorials/#using-the-metadata-download-in-the-previous-step","title":"Using the Metadata Download in the Previous Step","text":"<pre><code>kirsche connections -meta paper_metadata.json -t paper_connections.json\n</code></pre> Example of Saved Result <p>This command will create a json file (e.g., <code>paper_connections.json</code>) that contains some metadata and an extra field <code>local__referenced_to</code> which links to other records in the same file.</p> <pre><code>{\n    \"authors\": [\n        {\n            \"authorId\": \"2605353\",\n            \"name\": \"D. Reato\",\n            \"url\": \"https://www.semanticscholar.org/author/2605353\"\n        },\n        {\n            \"authorId\": \"2589386\",\n            \"name\": \"M. Bikson\",\n            \"url\": \"https://www.semanticscholar.org/author/2589386\"\n        },\n        {\n            \"authorId\": \"2583773\",\n            \"name\": \"L. Parra\",\n            \"url\": \"https://www.semanticscholar.org/author/2583773\"\n        }\n    ],\n    \"corpusId\": 2453569,\n    \"doi\": \"10.1152/jn.00208.2014\",\n    \"numCitedBy\": 47,\n    \"numCiting\": 90,\n    \"title\": \"Lasting modulation of in vitro oscillatory activity with weak direct current stimulation.\",\n    \"venue\": \"Journal of Neurophysiology\",\n    \"year\": 2015,\n    \"local__referenced_to\": [\n        \"10.1113/jphysiol.2003.055772\",\n        \"10.1152/jn.00715.2011\",\n        \"10.1152/jn.00319.2011\",\n        \"10.1113/jphysiol.2012.247171\",\n        \"10.1016/j.brs.2009.03.007\",\n        \"10.1523/jneurosci.2059-10.2010\",\n        \"10.1016/j.neuron.2010.03.035\",\n        \"10.1523/jneurosci.0095-07.2007\"\n    ]\n},\n{\n    \"authors\": [\n        {\n            \"authorId\": \"9438545\",\n            \"name\": \"F. Farahani\",\n            \"url\": \"https://www.semanticscholar.org/author/9438545\"\n        },\n        {\n            \"authorId\": \"39934585\",\n            \"name\": \"G. Kronberg\",\n            \"url\": \"https://www.semanticscholar.org/author/39934585\"\n        },\n        {\n            \"authorId\": \"7657897\",\n            \"name\": \"Mohamad FallahRad\",\n            \"url\": \"https://www.semanticscholar.org/author/7657897\"\n        },\n        {\n            \"authorId\": \"6158426\",\n            \"name\": \"Hysell V. Oviedo\",\n            \"url\": \"https://www.semanticscholar.org/author/6158426\"\n        },\n        {\n            \"authorId\": \"2583773\",\n            \"name\": \"L. Parra\",\n            \"url\": \"https://www.semanticscholar.org/author/2583773\"\n        }\n    ],\n    \"corpusId\": 232291349,\n    \"doi\": \"10.1016/j.brs.2021.03.001\",\n    \"numCitedBy\": 11,\n    \"numCiting\": 59,\n    \"title\": \"Effects of direct current stimulation on synaptic plasticity in a single neuron\",\n    \"venue\": \"Brain Stimulation\",\n    \"year\": 2021,\n    \"local__referenced_to\": [\n        \"10.1152/jn.00208.2014\",\n        \"10.1113/jphysiol.2003.055772\",\n        \"10.1152/jn.00208.2014\",\n        \"10.1016/j.brs.2009.03.007\",\n        \"10.1523/jneurosci.2059-10.2010\",\n        \"10.1016/j.neuron.2010.03.035\",\n        \"10.1002/ana.24708\",\n        \"10.1113/jp273005\",\n        \"10.1016/j.brs.2016.10.001\",\n        \"10.1016/j.brs.2019.10.014\"\n    ]\n},\n// ... omitted all other records here\n]\n</code></pre>"},{"location":"tutorials/#using-some-dois","title":"Using Some DOIs","text":"<p>This command also works with DOI as inputs.</p> <pre><code>kirsche connections -p \"10.1016/j.sna.2020.112529\" -p \"10.1152/jn.00208.2014\" -t paper_connections.json\n</code></pre>"},{"location":"tutorials/#using-a-bib-file_1","title":"Using a bib file","text":"<p>Similarly, we can use a bib file as input.</p> <pre><code>kirsche connections -bib my_bib_input.bib -t paper_connections.json\n</code></pre>"},{"location":"tutorials/#visualizations","title":"Visualizations","text":"<p>The connection file can already be loaded into some code or tools to be further processed. However, if we would like to have a quick look at the connections, kirsche also provides a simple visualization tool.</p> <p>If we already have the metadata (e.g.,<code>paper_metadata.json</code>) or connection  (e.g., <code>paper_connections.json</code>), we can use those to produce an interactive visualization,</p> <pre><code>kirsche visualization -meta paper_metadata.json -t paper_connection_visualization.html\n</code></pre> <pre><code>kirsche visualization -conn paper_connections.json -t paper_connection_visualization.html\n</code></pre>"},{"location":"tutorials/#the-end2end-pipeline-visualizations-from-a-list-of-papers","title":"The End2End Pipeline: Visualizations from a List of Papers","text":"<p>Suppose we have a bib file called <code>test.bib</code>, and we would like to generate an html file called <code>test.html</code>,</p> Command <pre><code>kirsche visualization -bib \"test.bib\" -t \"test.html\"\n</code></pre> <p>Open the <code>test.html</code> file in your browser.</p> Results <p></p>"},{"location":"tutorials/github-actions/","title":"Use in GitHub Actions","text":"<p>GitHub Actions is a great tool to automate your workflows.</p> <p>Paperpile</p> <p>Paperpile can automatically backup bib files in git repositories. Using GitHub Actions, we can perform some magic on our paperpile backups.</p>"},{"location":"tutorials/github-actions/#setup-actions-to-visualize-bib-files","title":"Setup Actions to Visualize bib Files","text":"<p>Demo Repository</p> <p>We have setup a demo repository here: kausalflow/connected-references-demo.</p> <p>The following is a demo.</p> Result <p>The following files will be created</p> <pre><code>data\n\u251c\u2500\u2500 connections-climate_change\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 12868807.json\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 128770297.json\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 14298480.json\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 154857890.json\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1614769.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 27573.json\n\u2514\u2500\u2500 visualizations\n    \u2514\u2500\u2500 climate_change.html\n</code></pre> <p>And a new branch (<code>gh-pages</code>) will be created using the content inside <code>data/visualizations</code>. Set up your github pages using this branch to see the website.</p> <p></p> GitHub Actions Configurations <p>Suppose your bib file is located at <code>references/climate_change.bib</code> in your repo.</p> <p>Create a file in your repo: <code>.github/workflows/visualize_climate_change.yaml</code> and fill it with the following.</p> <pre><code>name: Visualize Climate Change Papers\non:\n    push:\n        branches:\n        - main\n    schedule:\n        - cron:  '5 7/5 * * *'\n    workflow_dispatch:\n        inputs:\n        name:\n            description: 'Hit it now'\n            required: false\n            default: 'I Just wanna do it'\n\njobs:\n    deploy:\n        runs-on: ubuntu-latest\n        steps:\n        - name: Checkout current repo\n            uses: actions/checkout@v2\n        - name: Get current directory and files\n            run: |\n            pwd\n            ls\n        - uses: actions/setup-python@v2\n            with:\n            python-version: '3.7' # Version range or exact version of a Python version to use, using SemVer's version range syntax\n            architecture: 'x64' # optional x64 or x86. Defaults to x64 if not specified\n        - name: Install Python Requirements\n            run: |\n            python --version\n            pip install kirsche\n        - name: Download Records\n            run: |\n            kirsche connections -sb references/climate_change.bib -c data/connections-climate_change/\n            kirsche visualization -sc data/connections-climate_change/ -th data/visualizations/climate_change.html\n            git config --local user.email \"action@github.com\"\n            git config --local user.name \"GitHub Action\"\n            git pull\n            git status\n            git add .\n            git commit -m \"Update Meta and Visualize\" || echo \"Nothing to update\"\n            git pull\n            git status\n        - name: Push changes\n            uses: ad-m/github-push-action@v0.6.0\n            with:\n            branch: main\n            github_token: ${{ secrets.GITHUB_TOKEN }}\n        - name: Deploy Visualizations\n            uses: peaceiris/actions-gh-pages@v3\n            with:\n            github_token: ${{ secrets.GITHUB_TOKEN }}\n            publish_dir: ./data/visualizations/\n            publish_branch: gh-pages\n</code></pre> Setup GitHub Pages <p></p> <p>Using this GitHub Actions, the visualization will be updated whenever new references are added to the bib file.</p> <p>Limitations</p> <p>Since SemanticScholar API only allows 100 records per 5 min, it is not practical to visualize millions of papers. But don't worry about the limitations, we have implemented some mechanism to stop the query at the right moment. Since all meta files are saved, the scheduled runs will download records that are left from the previous runs.</p> <p>Just in case, here is the setting for the schedules:</p> <pre><code>      schedule:\n        - cron:  '5 7/5 * * *'\n</code></pre>"},{"location":"tutorials/use-in-code/","title":"Use in Code","text":"<p>The command line tool covers most of the use cases. If more customizations is desired, please refer to References for details about the utilities.</p>"},{"location":"tutorials/use-in-code/#an-example","title":"An Example","text":"<pre><code>from kirsche.download import download_metadata\nfrom kirsche.connect import (\n    append_connections,\n    save_connected_papers,\n)\n\npaper_ids = [\"10.1523/JNEUROSCI.0095-07.2007\"]\n\n# download the metadata\npapers_metadata = download_metadata(paper_ids)\n\n# calculate the connections\npapers_connections = append_connections(papers_metadata)\n\n# save the connections to a file, e.g., save_paper_connections.json\nsave_connected_papers(papers_connections, target=\"save_paper_connections.json\")\n</code></pre> <p>Loading from a bib file</p> <p>If we have a bib file <code>my_input_bib_file.bib</code>, we can extract the ids using <code>list_unique_ids</code></p> <pre><code>from kirsche.download import list_unique_ids\n\npaper_ids = list_unique_ids(\"my_input_bib_file.bib\")\n</code></pre>"}]}